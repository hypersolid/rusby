use std::io::{self, Write};
use std::ffi::{CStr,CString};
use std::os::raw::c_char;

// this function folds ffi arguments and unfolds result to ffi types
#[no_mangle]
pub extern "C"
 fn ffi_distance(s_pointer: *const c_char, t_pointer: *const c_char) -> i32 {
let s = unsafe { CStr::from_ptr(s_pointer).to_string_lossy().into_owned() };
let t = unsafe { CStr::from_ptr(t_pointer).to_string_lossy().into_owned() };
let result = distance(s, t);
return result;
}

#[allow(unused_mut)]
fn distance(s: String, t: String) -> i32 {
let mut m = s.len();
let mut n = t.len();
if n==0 {
return m as i32;
}

if m==0 {
return n as i32;
}


let mut d = vec![vec![0; n + 1]; m + 1]; // generated by Rusby::Preprocessor
for i in 0..(m + 1) {
d[i as usize][0 as usize]=i
}
for j in 0..(n + 1) {
d[0 as usize][j as usize]=j
}
for j in 1..(n + 1) {
for i in 1..(m + 1) {
d[i as usize][j as usize]=if s.chars().nth((i-1) as usize)==t.chars().nth((j-1) as usize) {
d[(i-1) as usize][(j-1) as usize]
}
else {
let mut deletion = d[(i-1) as usize][j as usize]+1;
let mut insertion = d[i as usize][(j-1) as usize]+1;
let mut substitution = d[(i-1) as usize][(j-1) as usize]+1;
let mut op = if deletion<insertion {
deletion
}
else {
insertion
}
;
if op<substitution {
op
}
else {
substitution
}
}

}
}
return d[m as usize][n as usize] as i32;
}